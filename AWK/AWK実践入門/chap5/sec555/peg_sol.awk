##====================================================================
##
##--------------------------------------------------------------------
##
##====================================================================


##====================================================================
##  盤面データの格納
##====================================================================

{
    ##----  定数
    STN = 1    # 石
    NUL = 0    # 空
    EXT = 2    # 禁
    ##----  初期化
    Brd[NR][1] = ""
    split($0, Brd[NR])
    if ( nx < NF )  nx = NF    # 横サイズ
}

##====================================================================
##  ソリティアの解法と出力
##====================================================================

END  {
    ny = NR              # 縦サイズ
    Ope[0]["px"] = ""
    Ope[0]["py"] = ""
    ct = ct_brd()
    if ( ! sol_solve(0, ct) ) { print "無解" }
}

##====================================================================
##  ソリティアの解法
##====================================================================

function sol_solve(st, ct,    px, py) {
    ##----  初期条件
    if ( ct == 0 )  return 0    # 解に不達
    if ( ct == 1 ) {            # 解に到達
        output_solution(st)     # 解の出力
        return 1
    }
    ##----  着手の仮実行
    for ( px = 1; px <= nx; px++ ) {
        for ( py = 1; py <= ny; py++ ) {
            if ( Brd[py][px] != STN )  continue
            if ( dir_ope(st, ct, px, py) )  return 1
        }
    }
    return 0
}

##====================================================================
##  各方向での着手
##====================================================================

function dir_ope(st, ct, px0, py0,    px1, py1, px2, py2, dx, dy) {
    ##----  8方向での着手
    for ( dx = -1; dx <= +1; dx++ ) {
        for ( dy = -1; dy <= +1; dy++ ) {
            ##----  着手の適用条件の確認
            if ( dx == 0 && dy == 0 )  continue
            px1 = px0+dx; py1 = py0+dy
            px2 = px1+dx; py2 = py1+dy
            if ( px2 < 1 || px2 > nx )  continue
            if ( py2 < 1 || py2 > ny )  continue
            if ( Brd[py1][px1] != STN )  continue
            if ( Brd[py2][px2] != NUL )  continue
            ##----  着手の格納
            Ope[st]["px"] = px0
            Ope[st]["py"] = py0
            Ope[st]["dx"] = dx
            Ope[st]["dy"] = dy
            ##----  着手の実行(盤面の更新)
            Brd[py0][px0] = NUL
            Brd[py1][px1] = NUL
            Brd[py2][px2] = STN
            st++
            ct--
            ##----  着手の再帰呼出
            if ( sol_solve(st, ct) )  return 1
            ##----  着手の反行(盤面の元戻)
            Brd[py0][px0] = STN
            Brd[py1][px1] = STN
            Brd[py2][px2] = NUL
            st--
            ct++
        }
    }
    return 0
}

##====================================================================
##  盤面上の石数
##====================================================================

function ct_brd(    ct, kx, ky) {
    ct = 0;
    for ( kx = 1; kx <= nx; kx++ ){
        for ( ky = 1; ky <= ny; ky++ ) {
            if ( Brd[ky][kx] == 1 )  ct++
        }
    }
    return ct
}

##====================================================================
##  盤面の出力
##====================================================================

##====  盤面の出力
function output_brd(nx, ny) {
    for ( ky = 1; ky <= ny; ky++ ) {
        for ( kx = 1; kx <= nx; kx++) {
            printf Brd[ky][kx] " "
        }
        print ""
    }
    print ""
}

##====================================================================
##  解手順の出力
##====================================================================

##====  解手順の出力
function output_solution(st) {
    while ( st > 0 ) {
        output_brd(nx, ny);
        st--;
        ##----  着手
        px0 = Ope[st]["px"];
        py0 = Ope[st]["py"];
        dx = Ope[st]["dx"];
        dy = Ope[st]["dy"];
        px1 = px0+dx; px2 = px1+dx;
        py1 = py0+dy; py2 = py1+dy;
        ##----  着手の出力
        #print ct-st-1 ": <" px0 "," py0 "> : <" dx "," dy ">";
        printf("%2d : <%d,%d> : <%+2d,%+2d>\n", ct-st-1, py0, px0, dy,dx);
        ##----  ロールバック
        Brd[py0][px0] = 1;
        Brd[py1][px1] = 1;
        Brd[py2][px2] = 0;
    }
    output_brd(nx, ny);
}
