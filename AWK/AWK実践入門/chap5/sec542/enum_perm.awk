##====================================================================
##  再帰法を用いた順列と組合せの列挙
##--------------------------------------------------------------------
##  enum_perm.awk
##====================================================================


##====================================================================
##  本体処理
##====================================================================

{
    n = $1;
    m = $2;
    printf "重複順列   : "
    a = enum_perm_dp_rec(n, m);
    print " ; " a;
    printf "単純順列   : "
    a = enum_perm_sg_rec(n, m);
    print " ; " a;
    printf "重複組合せ : "
    a = enum_combi_dp_rec(n, m);
    print " ; " a;
    printf "単純組合せ : "
    a = enum_combi_sg_rec(n, m);
    print " ; " a;
}


##====================================================================
##  関数定義
##====================================================================

##--------------------------------------------------------------------
##  配列の出力
##--------------------------------------------------------------------

function seq_output(arr, m,   k) {
    for ( k = 0; k < m; k++ ) { printf arr[k]; }
    printf " ";
}

##--------------------------------------------------------------------
##  再帰法による重複順列の列挙
##--------------------------------------------------------------------

function enum_perm_dp_rec(n, m, p, seq,   k, s) {
    if ( p == 0 ) { s = 0; }
    ##----  試行列の出力
    if ( p == m ) { seq_output(seq, m); return 1; }
    ##----  下位節の分岐
    for ( k = 0; k < n; k++ ) {
        ##----  試行列を伸長
        seq[p++] = k;
        ##----  再帰呼出
        s += enum_perm_dp_rec(n, m, p, seq);
        ##----  試行列を縮小
        p--;
    }
    return s;
}

##--------------------------------------------------------------------
##  再帰法による単純順列の列挙
##--------------------------------------------------------------------

function enum_perm_sg_rec(n, m, p, seq, dgt,   k, s) {
    ##----  初期化
    if ( p == 0 ) { s = 0; }
    ##----  試行列の出力
    if ( p == m ) { seq_output(seq, m); return 1; }
    ##----  下位節の分岐
    for ( k = 0; k < n; k++ ) {
        if ( dgt[k] == 1 ) { continue; }
        ##----  試行列を伸長
        seq[p++] = k; dgt[k] = 1;
        ##----  再帰呼出
        s += enum_perm_sg_rec(n, m, p, seq, dgt);
        ##----  試行列を縮小
        p--; dgt[k] = 0;
    }
    return s;
}

##--------------------------------------------------------------------
##  再帰法による重複組合せの列挙
##--------------------------------------------------------------------

function enum_combi_dp_rec(n, m, p, seq, d,   k, s) {
    ##----  初期化
    if ( p == 0 ) { s = 0; d = 0;  }
    ##----  列の出力
    if ( p == m ) { seq_output(seq, m); return 1; }
    ##----  下位節の分岐
    for ( k = d; k < n; k++ ) {
        ##----  試行列を伸長
        seq[p++] = k;
        ##----  再帰呼出
        s += enum_combi_dp_rec(n, m, p, seq, k);
        ##----  試行列を縮小
        p--;
    }
    return s;
}

##--------------------------------------------------------------------
##  再帰法による単純組合せの列挙
##--------------------------------------------------------------------

function enum_combi_sg_rec(n, m, p, seq, d,   k, s) {
    ##----  初期化
    if ( p == 0 ) { s = 0; d = 0; }
    ##----  列の出力
    if ( p == m ) { seq_output(seq, m); return 1; }
    ##----  下位節の分岐
    for ( k = d; k < n; k++ ) {
        ##----  試行列を伸長
        seq[p++] = k;
        ##----  再帰呼出
        s += enum_combi_sg_rec(n, m, p, seq, k+1);
        ##----  試行列を縮小
        p--;
    }
    return s;
}
