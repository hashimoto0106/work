##====================================================================
##  記数法を用いた順列と組合せの完全列挙
##  enum_full.c
##====================================================================

##====================================================================
##  事前処理
##====================================================================

BEGIN {
    ROOT = -1;
    ZERO = 0;
    NONE = 2;
    OPEN = 0;
    CLOSED = 1;
    MAX = 100000;
    ky = 0;
}


##====================================================================
##  本体処理
##====================================================================

NR == 1 {
    deg = split($0, Label);
    for ( k = 0; k < deg; k++ ) { Label[k] = Label[k+1]; }
    next;
}

##---------------------------------------------------------------------
{
    for ( k = 1; k <= deg; k++ ) { Matr[ky][k-1] = $k; }
    ky++;
}


##====================================================================
##  事後処理
##====================================================================

END {
    getline $0 < "/dev/stdin";;
    s1 = $1; s2 = $2;
    n1 = arr_index(Label, deg, s1);
    n2 = arr_index(Label, deg, s2);

    for ( k = 0; k < deg; k++ ) { Val[k] = ZERO; Upper[k] = ROOT; Check[k] = NONE; }

    printf "  "
    for ( k = 0; k < deg; k++ ) { printf " " Label[k]; }
    print ""

    for ( ky = 0; ky < deg; ky++ ) {
        printf " " Label[ky]
        for ( kx = 0; kx < deg; kx++ ) {
            printf " " Matr[ky][kx];
        }
        print ""
    }

    dijkstra(n1, n2, deg);
}


##====================================================================
##  関数定義
##====================================================================

##--------------------------------------------------------------------
##  配列の出力
##--------------------------------------------------------------------

function dijkstra(n1, n2, deg) {
    ##----  探索算法
    Check[n1] = OPEN;
    while ( 1 ) {
        if ( open_null(deg) ) { print "無解"; return; }
        p = open_min(deg);    # 評価値が最小の要素
        Check[p] = CLOSED;    # 探索済集合に格納

        if ( p == n2 ) { print "Success"; output_path(p); return; }
        for ( q = 0; q < deg; q++ ) {
            if ( Matr[p][q] > ZERO ) {
                v = Val[p] + Matr[p][q];    # 評価値の計算
                if ( Check[q] == NONE ) {
                    Val[q] = v; Upper[q] = p; Check[q] = OPEN;
                } else if ( Check[q] == OPEN ) {
                    if ( Val[q] > v ) { Val[q] = v; Upper[q] = p; }
                }
            }
        }
    }
}

##--------------------------------------------------------------------
##  配列の出力
##--------------------------------------------------------------------

function open_null(deg) {
    for ( k = 0; k < deg; k++ ) {
        if ( Check[k] == OPEN ) { return 0; }
    }
    return 1;
}

##--------------------------------------------------------------------
##  最小要素の取出し
##--------------------------------------------------------------------

function open_min(deg) {
    p = ROOT; m = MAX;
    for ( k = 0; k < deg; k++ ) {
        if ( Check[k] != OPEN ) { continue; }
        if ( Check[k] != OPEN ) { continue; }
        if ( m > Val[k] ) { p = k; m = Val[k]; }
    }
    return p;
}

##--------------------------------------------------------------------
##  配列の出力
##--------------------------------------------------------------------

function output_path(p) {
    while ( p != ROOT ) {
        printf Label[p] " - ";
        p = Upper[p];
    }
    print ""
}

##--------------------------------------------------------------------
##  配列の出力
##--------------------------------------------------------------------

function arr_output(arr, n,  k) {
    for ( k = 0; k < n; k++ ) { printf " " arr[k]; }
    print "";
}

##--------------------------------------------------------------------
##  配列の指定要素の位置
##--------------------------------------------------------------------

function arr_index(arr, n, val,    k) {
    for ( k = 0; k < n; k++ ) {
        if ( arr[k] == val ) { return k; }
    }
    return NONE;
}
