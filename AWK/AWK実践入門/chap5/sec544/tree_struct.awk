##====================================================================
##  親子関係からの木構造の構成
##--------------------------------------------------------------------
##
##====================================================================

# idx[x]       自ノードの番号
# degree[x]    各ノードの次数
# depth[x]     各ノードの深さ
# height[x]    各ノードの高さ
# parent[x]    親ノード
# child[x]     子ノードのリスト

# list_node[x]    全ノードのリスト
# list_leaf[x]    葉ノードのリスト

# tr_root      根ノード
# tr_wgt       ノードの総数(重さ)
# tr_hgt       最大世代(高さ)
# tr_deg       最大分岐(次数)
# tr_wid       葉ノードの総数(広さ)


##====================================================================
##
##====================================================================

##--------------------------------------------------------------------
##
##--------------------------------------------------------------------

BEGIN {
    ##----  定数
    NONE = " ";    # 空ノード
    STRL = 4;      # ラベル幅
}

##--------------------------------------------------------------------
##
##--------------------------------------------------------------------

/^[_:A-Za-z0-9]/ {
    ##----  ノードの計量の格納
    x = $1;               # ノードのラベル
    #node[tr_wgt] = x;     # ラベルの添字配列への格納
    #idx[x] = tr_wgt++;    # 添字の連想配列への格納
    list_node[x] = 1;     # 全ノードのリストへの登録
    degree[x] = NF-1;     # ノードの次数
    height[x] = 1;        # 高さは1に初期化

    ##----  葉ノードの処理
    if ( degree[x] == 0 ) {    # 子ノードが無い
        height[x] = 0;         # 高さは0
        list_leaf[x] = 1;      # 葉ノードのリストへの登録
        tr_wid++;              # 木構造の幅の計数
    }

    ##----  根ノードの処理
    if ( ! tr_root ) {         # 根ノードが未定義
        tr_root = x;           # 根ノードとして登録
        depth[x] = 0;          # 深さは0
        parent[x] = NONE;      # 親ノードは空
    }

    ##----  親子関係の格納(双方向)
    for ( k = 2; k <= NF; k++ ) {
        parent[$k] = x;            # 親ノードの登録
        depth[$k] = depth[x]+1;    # ノードの記述が幅優先でないとき正しく計算されない
    }
    for ( k = 2; k <= NF; k++ ) {
        child[x][$k] = 1;      # 子ノードのリストへの登録
        calc_height_upp(x);    # ノードの記述が幅優先でないとき正しく計算されない
    }

    ##----  木構造の計量の計算
    if ( tr_deg < degree[x] ) { tr_deg = degree[x]; }      # 最大次数
    if ( tr_hgt-1 < depth[x] ) { tr_hgt = depth[x]+1; }    # 高さ
}

##--------------------------------------------------------------------
##
##--------------------------------------------------------------------

END {
    ##----  各ノードの情報の計算(ノードの記述が幅優先なら不要)
    calc_height();    # 各ノードの高さ
    calc_depth();     # 各ノードの深さ
    ##----  木構造の計量の出力
    print "##  全体"
    print "重さ : " tr_wgt
    print "次数 : " tr_deg
    print "幅   : " tr_wid
    print "高さ : " tr_hgt
    ##----  各ノードの情報の出力
    print "##  各ノード";
    printf("番 %-" STRL "s: %-" STRL "s; 次 深 高\n", "節", "親");
    for ( x in list_node ) {
        printf("%02d %-" STRL "s : %-" STRL "s ; ", idx[x], x, parent[x]);
        printf("%2d %2d %2d\n", degree[x], depth[x], height[x]);
    }
    ##----  子ノードの出力
    print "##  子ノードのリスト"
    for ( x in list_node ) {
        if ( ! isarray(child[x]) ) { continue; }
        printf x " : ";
        for ( c in child[x] ) {
            printf c " ";
        }
        print ""
    }
}


##====================================================================
##  関数定義
##====================================================================

##--------------------------------------------------------------------
##  上位ノードの高さの再計算
##--------------------------------------------------------------------

function calc_height_upp(nd,    h, pt) {
    while ( nd != tr_root ) {
        h = height[nd];
        pt = parent[nd];
        if ( pt == "" ) { break; }    # ノードの記述が幅優先でないとき無限ループを防ぐ
        if ( height[pt] < h+1 ) { height[pt] = h+1; }
        nd = parent[nd];
    }
}

##--------------------------------------------------------------------
##  各ノードの高さの計算
##--------------------------------------------------------------------

function calc_height(    x) {
    for ( x in list_leaf ) {       # 葉ノードに対して反復処理
        calc_height_upp(x);        # 上位ノードに遡って計算
    }
    tr_hgt = height[tr_root]+1;    # 木の高さの計算
}

##--------------------------------------------------------------------
##  各ノードの深さの計算
##--------------------------------------------------------------------

function calc_depth(    x, p) {
    for ( x in list_node ) {    # 全ノードで反復処理
        depth[x] = 0;
        p = x;
        while ( p != tr_root ) {
            depth[x]++;
            p = parent[p];
        }
    }
}
