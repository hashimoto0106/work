##====================================================================
##
##--------------------------------------------------------------------
##
##====================================================================


##====================================================================
##  事前処理
##====================================================================

BEGIN  {
    fname1 = "doc1.txt"
    fname2 = "doc2.txt"
}


##====================================================================
##  本体処理
##====================================================================

FILENAME == fname1 {
    for ( k = 1; k <= NF; k++ ) { arr1[n1++] = $k; }
}


FILENAME == fname2 {
    for ( k = 1; k <= NF; k++ ) { arr2[n2++] = $k; }
}


##====================================================================
##  事後処理
##====================================================================

END {
    print n1 ", " n2 " : " leven(arr1, arr2);
}


##====================================================================
##  関数定義
##====================================================================

##--------------------------------------------------------------------
##  ハミング距離
##--------------------------------------------------------------------

function hamming(s1, s2,  ct) {
    ct = 0;
    while ( s1 != "" && s2 != "" ) {
        c1 = substr(s1, 1, 1); s1 = substr(s1, 2);
        c2 = substr(s2, 1 ,1); s2 = substr(s2, 2);
        if ( c1 != c2 ) { ct++; }
    }
    ct += length(s1) + length(s2);
    return ct;
}

##--------------------------------------------------------------------
##  再帰法によるレーベンシュタイン距離の計算
##--------------------------------------------------------------------

function leven_rec(s1, s2,  ct, c1, c2, t1, t2, m1, m2) {
    if ( s2 == "" ) { return length(s1); }
    if ( s1 == "" ) { return length(s2); }
    c1 = substr(s1, 1, 1);    # 先頭の文字
    c2 = substr(s2, 1 ,1);    # 先頭の文字
    t1 = substr(s1, 2);       # 残余の文字列
    t2 = substr(s2, 2);       # 残余の文字列
    ct = leven_rec(t1, t2);
    if ( c1 == c2 ) { return ct; }
    m1 = leven_rec(t1, s2);
    m2 = leven_rec(s1, t2);
    if ( ct > m1 ) { ct = m1; }
    if ( ct > m2 ) { ct = m2; }
    return ct+1;
}

##--------------------------------------------------------------------
##  動的計画法によるレーベンシュタイン距離の計算
##--------------------------------------------------------------------

function leven(arr1, arr2,    tab, k1, k2) {
    len1 = length(arr1);
    len2 = length(arr2);
    for ( k1 = 0; k1 <= len1; k1++ ) { tab[k1][0 ] = k1; }
    for ( k2 = 0; k2 <= len2; k2++ ) { tab[0 ][k2] = k2; }
    for ( k1 = 1; k1 <= len1; k1++ ) {
        for ( k2 = 1; k2 <= len2; k2++ ) {
            v0 = tab[k1-1][k2-1];
            v1 = tab[k1  ][k2-1];
            v2 = tab[k1-1][k2  ];
            tab[k1][k2] = v0;
            if ( arr1[k1] == arr2[k2] ) { continue; }
            if ( v0 > v1 ) { tab[k1][k2] = v1; }
            if ( v0 > v2 ) { tab[k1][k2] = v2; }
            tab[k1][k2]++;
        }
    }
    return tab[len1][len2];
}

##--------------------------------------------------------------------
##
##--------------------------------------------------------------------

function str_arr(str, arr,  len, k) {
    len = length(str);
    for ( k = 0; k < len; k++ ) {
      arr[k] = substr(str, k+1, 1);
    }
    return len;
}
